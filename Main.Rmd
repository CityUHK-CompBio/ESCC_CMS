

```{r}
options(java.parameters = "-Xmx50g")
library(bartMachine)
library(doParallel)
library(stringr)
library(car)
library(stringr)
library(ggpubr)
library(ggplot2)
library(cowplot)
library(caret)
library(ggalluvial)
##计算p值的function
P_cal <- function(clinical,labels){
            time <- clinical[, 1]
            event <- clinical[, 2] == 1
            df <- data.frame(futime = time, fustat = event, group = labels)
            surv <- survival::survfit(survival::Surv(futime, fustat) ~ 
                                        group, data = df)
            survstats <- survival::survdiff(survival::Surv(futime, fustat) ~ 
                                              group, data = df)
            survstats$p.value <- 1 - pchisq(survstats$chisq, length(survstats$n) - 
                                              1)
            return(survstats$p.value)
}
#画OS的function
myplot=function (clinical, labels, limit = NULL, annot = NULL, color = NULL, 
  font = "Arial", xlab = "Follow up", ylab = "Survival Probability", 
  title = NULL, legend.pos = "top", palette = "jama_classic", 
  risk.table = T, risk.table.ratio = 0.4, anno.pos = "bottom", 
  anno.x.shift = 0.5) 
{
  time <- clinical[, 1]
  event <- clinical[, 2] == 1
  if (!is.null(limit)) {
    event[time > limit] <- F
    time[time > limit] <- limit
  }
  df <- data.frame(futime = time, fustat = event, group = labels)
  surv <- survival::survfit(survival::Surv(futime, fustat) ~ 
    group, data = df)
  survstats <- survival::survdiff(survival::Surv(futime, fustat) ~ 
    group, data = df)
  survstats$p.value <- 1 - pchisq(survstats$chisq, length(survstats$n) - 
    1)
  if (!is.null(color)) {
    if (!is.null(names(color))) {
      labels <- factor(labels, levels = names(color))
    }
  }
  else {
    color <- get_color(palette, n = length(unique(labels)))
  }
  if (class(labels) == "factor") {
    legend.labs <- na.omit(levels(droplevels(labels[!(is.na(time) | 
      is.na(event))])))
  }
  else if (class(labels) == "logical") {
    labels <- factor(labels, levels = c(F, T))
    legend.labs <- na.omit(levels(droplevels(labels)))
  }
  else {
    legend.labs <- na.omit(unique(labels))
    labels <- factor(labels, levels = legend.labs)
  }
  fancy_scientific <- function(l, dig = 3) {
    l <- format(l, digits = dig, scientific = TRUE)
    l <- gsub("^(.*)e", "'\\1'e", l)
    l <- gsub("e", "%*%10^", l)
    parse(text = l)
  }
  p <- survminer::ggsurvplot(surv, data = df, xlab = xlab, 
    ylab = ylab, palette = color, legend = legend.pos, legend.labs = legend.labs, 
    risk.table = risk.table, risk.table.title = element_blank(), 
    risk.table.y.text = FALSE, ggtheme = cowplot::theme_cowplot())
  p$plot <- p$plot + ggtitle(title) + theme(plot.title = element_text(hjust = 0.5), 
    text = element_text(family = font), title = element_text(family = font), 
    axis.text.x = element_text(family = font), legend.title = element_blank())
  anno.text <- ifelse(survstats$p.value == 0, "italic(P)<1%*%10^{-22}", 
    paste0("italic(P)==", fancy_scientific(survstats$p.value, 
      3)))
  anno.y.shift <- 0
  if (length(legend.labs) == 2) {
    hr <- survcomp::hazard.ratio(labels[!(is.na(time) | 
      is.na(event))], time[!(is.na(time) | is.na(event))], 
      event[!(is.na(time) | is.na(event))])
    anno.text <- c(anno.text, sprintf("HR == %3.2f~(%3.2f - %3.2f)", 
      hr$hazard.ratio, hr$lower, hr$upper))
    anno.y.shift <- c(anno.y.shift + 0.15, 0)
  }
  if (!is.null(annot)) {
    anno.text <- c(anno.text, annot)
    anno.y.shift <- c(anno.y.shift + 0.15, 0)
  }
  if (anno.pos == "bottom") {
    p$plot <- p$plot + annotate("text", family = font, x = 0, 
      y = anno.y.shift, label = anno.text, hjust = 0, 
      vjust = 0, parse = TRUE)
  }
  else {
    p$plot <- p$plot + annotate("text", family = font, x = anno.x.shift * 
      max(time, na.rm = T), y = 0.85 + anno.y.shift, label = anno.text, 
      hjust = 0, vjust = 2, parse = TRUE)
  }
  if (risk.table) {
    p$table <- p$table + theme(text = element_text(family = font), 
      title = element_text(family = font), axis.text = element_text(family = font), 
      axis.title.y = element_blank())
    pp <- plot_grid(plotlist = list(p$plot + theme(axis.title.x = element_blank()), 
      p$table + labs(x = xlab)), labels = "", ncol = 1, 
      align = "v", rel_heights = c(1, risk.table.ratio))
    return(pp)
  }
  else return(p$plot)
}
```


```{r}

#Figure 4C

All_loc <- SXMI_loc_select
length(All_loc)

distributionOfPatch<- sapply(1:length(All_loc),function(i){
  mat <- All_loc[[i]]
  tmp <- c(length(which(mat==1)),length(which(mat==2)),length(which(mat==3)),length(which(mat==4)),length(which(mat==5)),
           length(which(mat==6)),length(which(mat==7)),length(which(mat==8)) )
  return(tmp)
})

rownames(distributionOfPatch) <-c('back','con', 'epi', 'gla', 'lym', 'mus', 'str', 'tum')
colnames(distributionOfPatch) <- names(All_loc)
distriOfPatch_yiqiOld <- distributionOfPatch

totalnum <- colSums(distriOfPatch_yiqiOld)
distributionOfPatch_ratio <- t(t(distriOfPatch_yiqiOld)/totalnum)

distriPlot <- data.frame(num=c(t(distributionOfPatch_ratio)))
distriPlot$class <- rep(c('BACK', 'CON', 'EPI', 'GLA', 'LYM', 'MUS', 'STR', 'TUM'),each=ncol(distributionOfPatch_ratio))
distriPlot$color <- factor(rep(c(1:8),each=ncol(distributionOfPatch_ratio)),) 

ggplot(distriPlot, aes(x=class, y=num,fill=color,color=color)) + 
  geom_boxplot(notch=T,notchwidth = 0.6,width = 0.6,lwd=1.5)+ # 
  stat_boxplot(geom ='errorbar',width = 0.4)+
  labs(title="", x="", y="")+   
  theme(axis.title.x = element_text(size = 15,family ="serif"),axis.title.y = element_text(size = 15,family ="serif"),
        plot.title = element_text( color="black", size=15,face="plain",hjust = 0.5,family ="serif"),
        axis.text.x = element_text(size=15,family ="serif"),axis.text.y = element_text(size=15,family ="serif"),axis.ticks = element_blank(),
        legend.position="none",
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"))+
  scale_fill_manual(values=c("#1974d2","#696969","#FFA343","NavajoWhite","#C364C5","#CD5C5C","#4682B4","#1CAC78"))+ # ,"#1974d2"
  scale_color_manual(values=c("#1974d2","#696969","#FFA343","NavajoWhite","#C364C5","#CD5C5C","#4682B4","#1CAC78"))

# graph2ppt(file="./A_distribution.pptx", width=8, height=5)
```



```{r}
#install extraTrees and dummies if you don't have one
#install.packages("./extraTrees_1.0.5.tar.gz", repos = NULL, type = "source")
#install.packages("./dummies_1.5.6.tar.gz", repos = NULL, type = "source")
##分析代表性不足的亚型&&筛选和新样本
ntree = 100
mtry = 2
numRandomCuts = 2
nodesize = 2

#load("./SXMI_sample.rdata")
Label4slides <- factor(Label4slides,levels = c(1,2,3,4),
                                       labels = c("ECMS1","ECMS2","ECMS3","ECMS4"))
Counts <- lapply(1:100,function(Times){
  set.seed(Times)
  ind <- sample(1:nrow(EQ_tissueOmics_multi_loc_004),ceiling(0.9*nrow(EQ_tissueOmics_multi_loc_004)),replace = FALSE)
  trainD <- EQ_tissueOmics_multi_loc_004[ind,]
  trainL <- Label4slides[ind]
  testD <- EQ_tissueOmics_multi_loc_004[-ind,]
  testL <- Label4slides[-ind]
  rfout <- extraTrees::extraTrees(trainD, trainL, ntree=ntree,mtry = mtry, numRandomCuts = numRandomCuts,nodesize=nodesize,numThreads = 8) # ,numThreads = 10
  rfpred = predict(rfout, testD) 
  #内存管理---
  rm(trainD)
  rm(trainL)
  rm(rfout)
  #内存管理---
  tmp <- rfpred==testL
  names(tmp) <- rownames(testD)
  gc()
  return(tmp)
})

Counts <- do.call(c,Counts)
gc()
uniqueNames <- unique(names(Counts))
ratio <- sapply(uniqueNames, function(xxx){
  tmp <- which(names(Counts)==xxx)
  tmp_ratio <- mean(Counts[tmp])
  # names(tmp_ratio) <- xxx
  return(tmp_ratio)
})

ratio <- ratio[match(names(Label4slides),names(ratio))] # !!!!!!
ind_discard <- which(ratio<=0.1)

Label4slides_selected <- Label4slides[-ind_discard]
temp1=as.data.frame(Label4slides_selected)

Label4slides_freq <- table(Label4slides)
Label4slides_selected_freq <- table(Label4slides_selected)
represent_ratio <- Label4slides_selected_freq / Label4slides_freq

# 代表性不足的类为4类
print(represent_ratio)
```



```{r}
#Figure5b
require(pROC)
require(ggplot2)
library(doParallel)
library(pROC)
########################################
# glm.scores rf.scores glm.labels  rf.labels are vectors

#save(scores, file = "./scores.rdata")
#save(labels, file = "./scores.rdata")
load("./scores.rdata")
load("./scores.rdata")
# roc line colors. e.g. if two rocs. color = c("black","red")
color = c("#00468BFF","#ED0000FF","#42B540FF","#0099B4FF")
########################################

set.seed(100)
roclist <- lapply(1:length(scores), function(i){
      index <- !is.na(scores[[i]])
      pROC::roc(labels[[i]][index], scores[[i]][index])
 })
 names(roclist) <- names(scores)
 dat.ci <- data.frame( x=NA, se.lower=NA, se.upper=NA, group = NA, y =NA, sp.lower = NA, sp.upper = NA )
 for(group_name in names(roclist)){
        registerDoParallel(10)
        se.ciobj <- ci.se(roclist[[group_name]], specificities = seq(0, 1, l = 100), boot.n = 2000, parallel = TRUE)
        registerDoParallel(10)
        sp.ciobj <- ci.sp(roclist[[group_name]], sensitivities = seq(0, 1, l = 100), boot.n = 2000, parallel = TRUE)
        dat.ci.tmp <- data.frame(x = as.numeric(rownames(se.ciobj)), se.lower = se.ciobj[, 1], se.upper = se.ciobj[, 3],  group = group_name, y = as.numeric(rownames(sp.ciobj)), sp.lower = sp.ciobj[, 1], sp.upper = se.ciobj[, 3] )
        dat.ci <- rbind(dat.ci, dat.ci.tmp)
}
dat.ci <- dat.ci[-c(1),]
annot <- c()
aucs <- c()
for(group_name in names(roclist)){
    auc <- pROC::ci(roclist[[group_name]])[c(2, 1, 3)]
    others <- pROC::coords(roclist[[group_name]], "best", ret = c("sensitivity", "specificity"), best.policy = "omit")

    annot <- c(annot, sprintf("%.2f (%.2f-%.2f)", auc[1], auc[2], auc[3])  ) # 常用，AUC CI 
    aucs <- c(aucs, auc[1])
}
annot <- paste0(stringr::str_pad(names(roclist), max(sapply(names(roclist), nchar))+1, "right"), "\t", annot)
colors <- color
names(colors) <- names(roclist)

roc_curve=pROC::ggroc(roclist, legacy.axes = TRUE, size=0.93) +  labs(x = "1 - Specificity", y = "Sensitivity") + scale_color_manual(labels = annot, values = colors ) + theme_classic() +  geom_abline(linetype = "dashed", alpha = 0.3) + coord_equal() + geom_ribbon( data = dat.ci, inherit.aes = FALSE, show.legend = FALSE, aes(x = 1-x, xmin = 1-sp.upper, xmax = 1-sp.lower, y =y, ymin = se.lower, ymax = se.upper, group=group, fill=as.factor(group)), alpha = 0.1) + scale_fill_manual(values=colors) + theme(legend.title = element_blank()) 

#graph2ppt(x=roc_curve,file="./roc_curve.pptx")
```


```{r}
#install.packages("readxl")  # 如果没有安装readxl包的话
library(readxl)

YQ_Clinical <- read_excel("./SXMII_clinical.xlsx")
```


```{r}

gotResults <- function(mtry = 2,numRandomCuts = 2,seed=42){
  set.seed(seed)
  rfout <- extraTrees::extraTrees(EQ_tissueOmics_multi_loc_004_selected, Label4slides_selected,ntree=100,mtry = mtry, numRandomCuts = numRandomCuts,nodesize=2,numThreads=10)
  
  extraTrees::prepareForSave(rfout)
  
  load("./A_prepared.rdata")
  
  YQ_Clinical=dataframeC #!换YQ的临床数据！

  xtest <- EQ_tissueOmics_multi_loc
  Pred_EQ <- predict(rfout,xtest)
  pred_EQ_prob <- predict(rfout,xtest, probability=TRUE)
  rm(xtest)
  gc()
  # major vote for each patient
  Names <- substr(rownames(EQ_tissueOmics_multi_loc),1,9)
  uniqueName <- unique(Names)
  Vote_max_slides_EQ <- list()
  # discard method 1-----------------------------------------------------------------
  for (xxx in uniqueName) {
    ind <- which(Names == xxx)  # 找到匹配的索引
    all_result <- Pred_EQ[ind[1]:ind[length(ind)]]
    frequency_table <- table(all_result)
    if (sum(frequency_table == max(frequency_table)) >= 2) {
      back <- NA
    }else {
      most_frequent_element <- names(frequency_table)[which.max(frequency_table)]
      back <- most_frequent_element
    }
    if (frequency_table[which.max(frequency_table)] != length(ind) && frequency_table[4] > 0) {
      back <- "ECMS4"
    }
    Vote_max_slides_EQ[[xxx]] <- back  # 将结果存储在列表中
  }
  #随机选取
  # set.seed(seed)
  # for (xxx in uniqueName) {
  #   ind <- which(Names == xxx)  # 找到匹配的索引
  #   all_result <- Pred_EQ[ind[1]:ind[length(ind)]]
  #   sample_result <- sample(all_result, size = 1)
  #   frequency_table <- table(sample_result)
  #   back <- names(frequency_table)[which.max(frequency_table)]
  #   Vote_max_slides_EQ[[xxx]] <- back
  # }
  #   for (xxx in uniqueName) {
  #   ind <- which(Names == xxx)  # 找到匹配的索引
  #   all_result <- Pred_EQ[ind[1]:ind[length(ind)]]
  #   frequency_table <- table(all_result)
  #   if (sum(frequency_table == max(frequency_table)) >= 2) {
  #     back <- NA
  #   }else {
  #     most_frequent_element <- names(frequency_table)[which.max(frequency_table)]
  #     back <- most_frequent_element
  #   }
  #   Vote_max_slides_EQ[[xxx]] <- back  # 将结果存储在列表中
  # }
  names(Vote_max_slides_EQ) <- uniqueName
  Vote_max_slides_EQ <- do.call(c,Vote_max_slides_EQ)

  Vote_max_slides_EQ <- Vote_max_slides_EQ[match(EQ_Clinical$IMID,names(Vote_max_slides_EQ))]
  #VoteM2[is.na(VoteM2)] <- "ECMS4"
  
  labels <- factor(Vote_max_slides_EQ)
  legend.labs <- as.vector(na.omit(unique(labels)))
  
  input <- as.data.frame(cbind(EQ_Clinical$os.time/30,EQ_Clinical$os.event)) 
  input$V1 <- as.numeric(input$V1)
  EQ_OSP <- P_cal(clinical = input,labels=labels)
  input <- as.data.frame( cbind(EQ_Clinical$rfs.time/30,EQ_Clinical$rfs.event)) 
  input$V1 <- as.numeric(input$V1)
  EQ_DFSP <- P_cal(clinical = input,labels=labels)
  #内存管理
  # YQ------------------------------------------
  Vote_max_slides_YQ <- list()
  xtest_YQ <- YQ_tissueOmics_multi_loc[,colnames(EQ_tissueOmics_multi_loc)]
  xtest_YQ <- scale(xtest_YQ)
  Pred_YQ <- predict(rfout,xtest_YQ)
  pred_YQ_prob <- predict(rfout,xtest_YQ, probability=TRUE)
  # major vote for each patient
  Names_YQ <- substr(rownames(YQ_tissueOmics_multi_loc),1,9)
  uniqueName_YQ <- unique(Names_YQ)
  rm(xtest_YQ)
  for (xxx in uniqueName_YQ) {
    ind <- which(Names_YQ == xxx)  # 找到匹配的索引
    all_result <- Pred_YQ[ind[1]:ind[length(ind)]]
    frequency_table <- table(all_result)
    if (sum(frequency_table == max(frequency_table)) >= 2) {
      back <- NA
    }else {
      most_frequent_element <- names(frequency_table)[which.max(frequency_table)]
      back <- most_frequent_element
    }
    if (frequency_table[which.max(frequency_table)] != length(ind) && frequency_table[4] > 0) {
      back <- "ECMS4"
    }
    Vote_max_slides_YQ[[xxx]] <- back  # 将结果存储在列表中
  }
  # set.seed(seed)
  # for (xxx in uniqueName_YQ) {
  #   ind <- which(Names_YQ == xxx)  # 找到匹配的索引
  #   all_result <- Pred_YQ[ind[1]:ind[length(ind)]]
  #   sample_result <- sample(all_result, size = 1)
  #   frequency_table <- table(sample_result)
  #   back <- names(frequency_table)[which.max(frequency_table)]
  #   Vote_max_slides_YQ[[xxx]] <- back
  # }
  #   for (xxx in uniqueName_YQ) {
  #   ind <- which(Names_YQ == xxx)  # 找到匹配的索引
  #   all_result <- Pred_YQ[ind[1]:ind[length(ind)]]
  #   frequency_table <- table(all_result)
  #   if (sum(frequency_table == max(frequency_table)) >= 2) {
  #     back <- NA
  #   }else {
  #     most_frequent_element <- names(frequency_table)[which.max(frequency_table)]
  #     back <- most_frequent_element
  #   } 
  #   Vote_max_slides_YQ[[xxx]] <- back  # 将结果存储在列表中
  # }
  names(Vote_max_slides_YQ) <- uniqueName_YQ
  Vote_max_slides_YQ <- do.call(c,Vote_max_slides_YQ)

  Vote_max_slides_YQ <- Vote_max_slides_YQ[match(YQ_Clinical$SZID,names(Vote_max_slides_YQ))]
  
  YQ_clinical_M1 <- YQ_Clinical[match(names(Vote_max_slides_YQ),YQ_Clinical$SZID),]
  YQ_clinical_M1$os.event_new <- str_replace_all(YQ_clinical_M1$os.event_new,"Deceased","1")
  YQ_clinical_M1$os.event_new <- str_replace_all(YQ_clinical_M1$os.event_new,"Living","0")
  YQ_clinical_M1$os.event_new[which(YQ_clinical_M1$os.event_new=="Loss to follow-up")] <- NA
  YQ_clinical_M1 <- YQ_clinical_M1[!is.na(YQ_clinical_M1$os.event_new),]
  YQ_clinical_M1$os.event_new <- as.numeric(YQ_clinical_M1$os.event_new)
  Vote_max_slides_YQ <- Vote_max_slides_YQ[match(YQ_clinical_M1$SZID,names(Vote_max_slides_YQ))]
  
  labels <- factor(Vote_max_slides_YQ)
  legend.labs <- as.vector(na.omit(unique(labels)))
  input <- as.data.frame( cbind(YQ_clinical_M1$os.time_new/30,YQ_clinical_M1$os.event_new)) 
  input$V1 <- as.numeric(input$V1)
  YQ_OSP <- P_cal(clinical = input,labels=labels)
  # Multi ---------------------------------------------------------------------------------
  xtest <- Multi_tissueOmics_multi_loc[,colnames(EQ_tissueOmics_multi_loc_004)]
  xtest <- scale(xtest)
  # dim(xtest)
  pred_New_prob <- predict(rfout,xtest, probability=TRUE)
  Pred_New <-predict(rfout,xtest)
  rm(xtest)
  # major vote for each patient------------------
  Names <- substr(rownames(Multi_tissueOmics_multi_loc),1,10)
  uniqueName <- unique(Names)
  Vote_max_slides_MT <- list()
  #discard method 1--------------------------------------------------------------------
  # set.seed(seed)
  # for (xxx in uniqueName) {
  #   ind <- which(Names == xxx)  # 找到匹配的索引
  #   all_result <- Pred_New[ind[1]:ind[length(ind)]]
  #   sample_result <- sample(all_result, size = 1)
  #   frequency_table <- table(sample_result)
  #   back <- names(frequency_table)[which.max(frequency_table)]
  #   Vote_max_slides_MT[[xxx]] <- back
  # }
  for (xxx in uniqueName) {
    ind <- which(Names == xxx)  # 找到匹配的索引
    all_result <- Pred_New[ind[1]:ind[length(ind)]]
    frequency_table <- table(all_result)
    if (sum(frequency_table == max(frequency_table)) >= 2) {
      back <- NA
    }else {
      most_frequent_element <- names(frequency_table)[which.max(frequency_table)]
      back <- most_frequent_element
    }
    if (frequency_table[which.max(frequency_table)] != length(ind) && frequency_table[4] > 0) {
      back <- "ECMS4"
    }
    Vote_max_slides_MT[[xxx]] <- back  # 将结果存储在列表中
  }
#   for (xxx in uniqueName) {
#   ind <- which(Names == xxx)  # 找到匹配的索引
#   all_result <- Pred_New[ind[1]:ind[length(ind)]]
#   frequency_table <- table(all_result)
#   if (sum(frequency_table == max(frequency_table)) >= 2) {
#     back <- NA
#   }else {
#     most_frequent_element <- names(frequency_table)[which.max(frequency_table)]
#     back <- most_frequent_element
#   } 
#   Vote_max_slides_MT[[xxx]] <- back  # 将结果存储在列表中
# }
  
  MultiClinical_M1 <- MultiClinical[match(names(Vote_max_slides_MT),MultiClinical$ImID),]
  MultiClinical_M1$os.event <- as.numeric(MultiClinical_M1$os.event)
  MultiClinical_M1 <- MultiClinical_M1[!is.na(MultiClinical_M1$os.event),]
  Vote_max_slides_MT <- Vote_max_slides_MT[match(MultiClinical_M1$ImID,names(Vote_max_slides_MT))]
  
  labels <- factor(unlist(Vote_max_slides_MT))
  legend.labs <- as.vector(na.omit(unique(labels)))
  input <- as.data.frame(cbind(MultiClinical_M1$os.time,MultiClinical_M1$os.event)) 
  input$V1 <- as.numeric(input$V1)

  MNew1 <- P_cal(clinical = input,labels=labels)
  
  pp <- c(EQ_OSP,EQ_DFSP,YQ_OSP,MNew1)
  names(pp) <- c("EQ_major_os","EQ_major_dfs","YQ_major_os","Multi_os")
  gc()
  return(list(Pvalue=pp,model=rfout))
}
```

```{r}
load("./Multi_tissueOmics_noCON_multi_loc_210428.rdata")
#97可以
rst <- lapply(1:1000, function(xx){
  tmp <- gotResults(mtry = 1,numRandomCuts = 1,seed = xx)
  return(tmp)
})

load("./rst_final_model_2024_0520.rdata")
for (i in 1:1000){
  if(rst[[i]]$Pvalue[1]<0.05 && rst[[i]]$Pvalue[3]<0.05){
    print(i)
  }
}
gc()
#save(rst, file = "./rst_final_model_2024_0520.rdata")#89可以
```

```{r}
#EQ_OS_DFS看趋势
load("./rst_final_model_2024_0520.rdata")
#seed = 738
#set.seed(seed)
rfout <- rst[[89]]$model #
load("./A_prepared.rdata")
xtest <- EQ_tissueOmics_multi_loc
Pred_EQ <- predict(rfout,xtest)
pred_EQ_prob <- predict(rfout,xtest, probability=TRUE)
#————————————————挑选的核心样本
merged_df <- merge(temp1, EQ_tissueOmics_multi_loc, by = "row.names", all = FALSE)
merged_df <- merged_df[, -c(1,2)]
Pred_EQ_core <- predict(rfout,merged_df)

#__________________
rm(xtest)
gc()
# major vote for each patient
Names <- substr(rownames(EQ_tissueOmics_multi_loc),1,9)
uniqueName <- unique(Names)
Vote_max_slides_EQ <- list()
frequency_table_list <- list()
# discard method 1-----------------------------------------------------------------
# for (xxx in uniqueName) {
#   ind <- which(Names == xxx)  # 找到匹配的索引
#   all_result <- Pred_EQ[ind[1]:ind[length(ind)]]
#   sample_result <- sample(all_result, size = 1)
#   frequency_table <- table(sample_result)
#   back <- names(frequency_table)[which.max(frequency_table)]
#   Vote_max_slides_EQ[[xxx]] <- back
# }
for (xxx in uniqueName) {
  ind <- which(Names == xxx)  # 找到匹配的索引
  all_result <- Pred_EQ[ind[1]:ind[length(ind)]]
  frequency_table <- table(all_result)
  frequency_table_list[[xxx]] <- frequency_table
  if (sum(frequency_table == max(frequency_table)) >= 2) {
    back <- NA
  }else {
    most_frequent_element <- names(frequency_table)[which.max(frequency_table)]
    back <- most_frequent_element
  }
  if (frequency_table[which.max(frequency_table)] != length(ind) && frequency_table[4] > 0) {
    back <- "ECMS4"
  }
  Vote_max_slides_EQ[[xxx]] <- back  # 将结果存储在列表中
}
#test1
# for (xxx in uniqueName) {
#   ind <- which(Names == xxx)  # 找到匹配的索引
#   all_result <- Pred_EQ[ind[1]:ind[length(ind)]]
#   frequency_table <- table(all_result)
#   frequency_table_list[[xxx]] <- frequency_table
#   if (sum(frequency_table == max(frequency_table)) >= 2) {
#     back <- NA
#   }else {
#     most_frequent_element <- names(frequency_table)[which.max(frequency_table)]
#     back <- most_frequent_element
#   }
#   Vote_max_slides_EQ[[xxx]] <- back  # 将结果存储在列表中
# }
# 定义阈值
# thresh1 <- 0.5
# thresh2 <- 0.5
# thresh3 <- 0.5
# thresh4 <- 0.4
# # 创建一个空的字符向量，用于存储分类结果
# shape <- character(nrow(pred_EQ_prob))
# # 循环遍历每一行
# for (i in 1:nrow(pred_EQ_prob)) {
#   row <- pred_EQ_prob[i, ]
#   if (row[1] > thresh1) {
#     shape[i] <- "ECMS1"
#   } else if (row[2] > thresh2) {
#     shape[i] <- "ECMS2"
#   } else if (row[3] > thresh3){
#     shape[i] <- "ECMS3"
#   } else if (row[4] > thresh4) {
#     shape[i] <- "ECMS4"
#   } else {
#     shape[i] <- NA
#   }
# }
# shape=as.factor(shape)
# 
# for (xxx in uniqueName) {
#   ind <- which(Names == xxx)  # 找到匹配的索引
#   all_result <- shape[ind[1]:ind[length(ind)]]
#   frequency_table <- table(all_result)
#   frequency_table_list[[xxx]] <- frequency_table
#   if (sum(frequency_table == max(frequency_table)) >= 2) {
#     back <- NA
#   }else {
#     most_frequent_element <- names(frequency_table)[which.max(frequency_table)]
#     back <- most_frequent_element
#   }
#   Vote_max_slides_EQ[[xxx]] <- back  # 将结果存储在列表中
# }
# for (xxx in uniqueName) {
#   ind <- which(Names == xxx)  # 找到匹配的索引
#   tmp_lab <- pred_EQ_prob[ind,]  # 获取相关的预测概率
#   tmp_lab_1 <- (which.max(tmp_lab)-1) %/% length(ind) +1 # 找到最大概率的类别
#   back <- c("ECMS1", "ECMS2", "ECMS3", "ECMS4")[tmp_lab_1]  # 将类别映射为标签
#   Vote_max_slides_EQ[[xxx]] <- back  # 将结果存储在列表中
# }
names(Vote_max_slides_EQ) <- uniqueName
Vote_max_slides_EQ <- do.call(c,Vote_max_slides_EQ)

Vote_max_slides_EQ <- Vote_max_slides_EQ[match(EQ_Clinical$IMID,names(Vote_max_slides_EQ))]
#VoteM2[is.na(VoteM2)] <- "ECMS4"
test=as.data.frame(Vote_max_slides_EQ)
#write.csv(test,"./EQpredict_patient_level.csv",row.names = TRUE,col.names = TRUE)
labels <- factor(Vote_max_slides_EQ)
legend.labs <- as.vector(na.omit(unique(labels)))

input <- as.data.frame(cbind(EQ_Clinical$os.time/30,EQ_Clinical$os.event)) 
input$V1 <- as.numeric(input$V1)
input$V1 <- as.numeric(input$V1)
EQ_OS <- myplot(input,labels,ylab="OS",font = "sans",
                  risk.table = T,risk.table.ratio = 0.4,title = "EQ prediction (vote)",
                  legend.pos = c(0.65,0.18),xlab="Follow up",color=c("#00468BFF", "#ED0000FF", "#42B540FF", "#0099B4FF","black"))

input <- as.data.frame( cbind(EQ_Clinical$rfs.time/30,EQ_Clinical$rfs.event)) 
input$V1 <- as.numeric(input$V1)
EQ_DFS <- myplot(input,labels,ylab="DFS",font = "sans",
                  risk.table = T,risk.table.ratio = 0.4,title = "EQ prediction (max)",
                  legend.pos = c(0.65,0.18),xlab="Follow up",color=c("#00468BFF", "#ED0000FF", "#42B540FF", "#0099B4FF"))
#YQ
Vote_max_slides_YQ <- list()
xtest_YQ <- YQ_tissueOmics_multi_loc[,colnames(EQ_tissueOmics_multi_loc)]
xtest_YQ <- scale(xtest_YQ)
Pred_YQ <- predict(rfout,xtest_YQ)
pred_YQ_prob <- predict(rfout,xtest_YQ, probability=TRUE)
# major vote for each patient6
Names_YQ <- substr(rownames(YQ_tissueOmics_multi_loc),1,9)
uniqueName_YQ <- unique(Names_YQ)
rm(xtest_YQ)
#set.seed(seed)
# for (xxx in uniqueName_YQ) {
#     ind <- which(Names_YQ == xxx)  # 找到匹配的索引
#     all_result <- Pred_YQ[ind[1]:ind[length(ind)]]
#     sample_result <- sample(all_result, size = 1)
#     frequency_table <- table(sample_result)
#     back <- names(frequency_table)[which.max(frequency_table)]
#     Vote_max_slides_YQ[[xxx]] <- back
#   }
for (xxx in uniqueName_YQ) {
  ind <- which(Names_YQ == xxx)  # 找到匹配的索引
  all_result <- Pred_YQ[ind[1]:ind[length(ind)]]
  frequency_table <- table(all_result)
  if (sum(frequency_table == max(frequency_table)) >= 2) {
    back <- NA
  }else {
    most_frequent_element <- names(frequency_table)[which.max(frequency_table)]
    back <- most_frequent_element
  }
  if (frequency_table[which.max(frequency_table)] != length(ind) && frequency_table[4] > 0) {
    back <- "ECMS4"
  }
  Vote_max_slides_YQ[[xxx]] <- back  # 将结果存储在列表中
}
# for (xxx in uniqueName_YQ) {
#   ind <- which(Names_YQ == xxx)  # 找到匹配的索引
#   tmp_lab <- pred_YQ_prob[ind,]  # 获取相关的预测概率
#   tmp_lab_1 <- (which.max(tmp_lab)-1) %/% length(ind) +1 # 找到最大概率的类别
#   back <- c("ECMS1", "ECMS2", "ECMS3", "ECMS4")[tmp_lab_1]  # 将类别映射为标签
#   Vote_max_slides_YQ[[xxx]] <- back  # 将结果存储在列表中
# }
# for (xxx in uniqueName_YQ) {
#   ind <- which(Names_YQ == xxx)  # 找到匹配的索引
#   all_result <- Pred_YQ[ind[1]:ind[length(ind)]]
#   frequency_table <- table(all_result)
#   if (sum(frequency_table == max(frequency_table)) >= 2) {
#     back <- NA
#   }else{
#     most_frequent_element <- names(frequency_table)[which.max(frequency_table)]
#     back <- most_frequent_element
#   }
#   Vote_max_slides_YQ[[xxx]] <- back  # 将结果存储在列表中
# }
YQ_Clinical = dataframeC
names(Vote_max_slides_YQ) <- uniqueName_YQ
Vote_max_slides_YQ <- do.call(c,Vote_max_slides_YQ)

Vote_max_slides_YQ <- Vote_max_slides_YQ[match(YQ_Clinical$SZID,names(Vote_max_slides_YQ))]

factor_labels <- labels(Vote_max_slides_YQ)

sum(Names_YQ %in% factor_labels)#1142张片子


YQ_clinical_M1 <- YQ_Clinical[match(names(Vote_max_slides_YQ),YQ_Clinical$SZID),]
YQ_clinical_M1$os.event_new <- str_replace_all(YQ_clinical_M1$os.event_new,"Deceased","1")
YQ_clinical_M1$os.event_new <- str_replace_all(YQ_clinical_M1$os.event_new,"Living","0")
YQ_clinical_M1$os.event_new[which(YQ_clinical_M1$os.event_new=="Loss to follow-up")] <- NA
YQ_clinical_M1 <- YQ_clinical_M1[!is.na(YQ_clinical_M1$os.event_new),]
YQ_clinical_M1$os.event_new <- as.numeric(YQ_clinical_M1$os.event_new)
Vote_max_slides_YQ <- Vote_max_slides_YQ[match(YQ_clinical_M1$SZID,names(Vote_max_slides_YQ))]

labels <- factor(Vote_max_slides_YQ)
legend.labs <- as.vector(na.omit(unique(labels)))
input <- as.data.frame( cbind(YQ_clinical_M1$os.time_new/30,YQ_clinical_M1$os.event_new))
input$V1 <- as.numeric(input$V1)
YQ_OSP <- P_cal(clinical = input,labels=labels)

YQ_OS <- myplot(input,labels,ylab="OS",font = "sans",
                  risk.table = T,risk.table.ratio = 0.4,title = "YQ prediction (Vote)",
                  legend.pos = c(0.65,0.18),xlab="Follow up",color=c("#00468BFF", "#ED0000FF", "#42B540FF", "#0099B4FF","black"))

xtest <- Multi_tissueOmics_multi_loc[,colnames(EQ_tissueOmics_multi_loc_004)]
xtest <- scale(xtest)
# dim(xtest)
pred_New_prob <- predict(rfout,xtest, probability=TRUE)
Pred_New <-predict(rfout,xtest)
rm(xtest)
# major vote for each patient------------------
Names <- substr(rownames(Multi_tissueOmics_multi_loc),1,10)
uniqueName <- unique(Names)
Vote_max_slides_MT <- list()
# discard method 1--------------------------------------------------------------------
# set.seed(seed)
# for (xxx in uniqueName) {
#   ind <- which(Names == xxx)  # 找到匹配的索引
#   all_result <- Pred_New[ind[1]:ind[length(ind)]]
#   sample_result <- sample(all_result, size = 1)
#   frequency_table <- table(sample_result)
#   back <- names(frequency_table)[which.max(frequency_table)]
#   Vote_max_slides_MT[[xxx]] <- back
# }
for (xxx in uniqueName) {
  ind <- which(Names == xxx)  # 找到匹配的索引
  all_result <- Pred_New[ind[1]:ind[length(ind)]]
  frequency_table <- table(all_result)
  if (sum(frequency_table == max(frequency_table)) >= 2) {
    back <- NA
  }else {
    most_frequent_element <- names(frequency_table)[which.max(frequency_table)]
    back <- most_frequent_element
  }
  if (frequency_table[which.max(frequency_table)] != length(ind) && frequency_table[4] > 0) {
    back <- "ECMS4"
  }
  Vote_max_slides_MT[[xxx]] <- back  # 将结果存储在列表中
}
MultiClinical_M1 <- MultiClinical[match(names(Vote_max_slides_MT),MultiClinical$ImID),]
MultiClinical_M1$os.event <- as.numeric(MultiClinical_M1$os.event)
MultiClinical_M1 <- MultiClinical_M1[!is.na(MultiClinical_M1$os.event),]
Vote_max_slides_MT <- Vote_max_slides_MT[match(MultiClinical_M1$ImID,names(Vote_max_slides_MT))]

labels <- factor(unlist(Vote_max_slides_MT))
legend.labs <- as.vector(na.omit(unique(labels)))
input <- as.data.frame(cbind(MultiClinical_M1$os.time,MultiClinical_M1$os.event)) 
input$V1 <- as.numeric(input$V1)

Multi_OS <- myplot(input,labels,ylab="OS",font = "sans",
                  risk.table = T,risk.table.ratio = 0.4,title = "Multi prediction (Vote)",
                  legend.pos = c(0.65,0.18),xlab="Follow up",color=c("#00468BFF", "#ED0000FF", "#42B540FF", "#0099B4FF"))

#  graph2ppt(x=EQ_OS,file="./EQ_OS.pptx")
#  graph2ppt(x=EQ_DFS,file="./EQ_DFS.pptx")
# # # 
#  graph2ppt(x=YQ_OS,file="./YQ_OS.pptx")
# write.csv(diff.res$diffResult$GroupECMS1,"./ECMS1_feature_p.csv",col.names = T,row.names = T)
# write.csv(diff.res$diffResult$GroupECMS2,"./ECMS2_feature_p.csv",col.names = T,row.names = T)
# write.csv(diff.res$diffResult$GroupECMS3,"./ECMS3_feature_p.csv",col.names = T,row.names = T)
# write.csv(diff.res$diffResult$GroupECMS4,"./ECMS4_feature_p.csv",col.names = T,row.names = T)
# write.csv(EQ_tissueOmics_multi_loc,"./EQ_all_tissue_feature.csv",row.names = T,col.names = T)
```

```{r}
# xtest <- Multi_tissueOmics_multi_loc[,colnames(EQ_tissueOmics_multi_loc_004)]
# xtest <- scale(xtest)
# # dim(xtest)
# pred_New_prob <- predict(rfout,xtest, probability=TRUE)
# Pred_New <-predict(rfout,xtest)
# rm(xtest)
# # major vote for each patient------------------
# Names <- substr(rownames(Multi_tissueOmics_multi_loc),1,10)
# uniqueName <- unique(Names)
# Vote_max_slides_MT <- list()
# # discard method 1--------------------------------------------------------------------
# for (xxx in uniqueName) {
#   ind <- which(Names == xxx)  # 找到匹配的索引
#   all_result <- Pred_New[ind[1]:ind[length(ind)]]
#   frequency_table <- table(all_result)
#   if (sum(frequency_table == max(frequency_table)) >= 2) {
#     back <- NA
#   }else {
#     most_frequent_element <- names(frequency_table)[which.max(frequency_table)]
#     back <- most_frequent_element
#   } 
#   if (frequency_table[which.max(frequency_table)] != length(ind) && frequency_table[4] > 0) {
#     back <- "ECMS4"
#   }
#   Vote_max_slides_MT[[xxx]] <- back  # 将结果存储在列表中
# }
# MultiClinical_M1 <- MultiClinical[match(names(Vote_max_slides_MT),MultiClinical$ImID),]
# MultiClinical_M1$os.event <- as.numeric(MultiClinical_M1$os.event)
# MultiClinical_M1 <- MultiClinical_M1[!is.na(MultiClinical_M1$os.event),]
# Vote_max_slides_MT <- Vote_max_slides_MT[match(MultiClinical_M1$ImID,names(Vote_max_slides_MT))]
# 
# labels <- factor(unlist(Vote_max_slides_MT))
# legend.labs <- as.vector(na.omit(unique(labels)))
# input <- as.data.frame(cbind(MultiClinical_M1$os.time,MultiClinical_M1$os.event)) 
# input$V1 <- as.numeric(input$V1)
# 
# Multi_OS <- myplot(input,labels,ylab="OS",font = "sans",
#                   risk.table = T,risk.table.ratio = 0.4,title = "Multi prediction (Vote)",
#                   legend.pos = c(0.65,0.18),xlab="Follow up",color=c("#00468BFF", "#ED0000FF", "#42B540FF", "#0099B4FF"))
```

```{r}
#EQ——sankeyplot_patient_level
library(ggalluvial)
library(export)

final_predict=read.csv("./EQpredict_patient_level.csv")
#ture_label=read.csv("./label4patients.csv")
sankeydf <- data.frame(y_pred = final_predict$Vote_max_slides_EQ, y_true = EQ_Clinical$SNF)
sankeydf <- sankeydf[complete.cases(sankeydf), ]
sankeydf$y_pred <- paste("im-", sankeydf$y_pred, sep = "")

colors=c("#00468BFF", "#ED0000FF", "#42B540FF", "#0099B4FF")
Sankey_patient=ggplot(sankeydf,
       aes(y =NULL,
           axis1 = y_pred, axis2 = y_true))+#定义图形绘制
  geom_alluvium(aes(fill = y_pred))+#控制线条流向 
  geom_stratum() +#控制中间框的宽度
 geom_text(stat = "stratum", aes(label = after_stat(stratum)),reverse = TRUE, size = 3,angle=2,discern = TRUE)+ #定义中间的文字
  scale_x_continuous(breaks = 1:2, labels = c("IM_ECMS", "ECMS"))+#定义X轴上图标排序
  scale_fill_manual(values = colors) +
  theme(legend.position = "none") +#定义图例有无
 ggtitle(" ")#定义图名
#graph2ppt(x=Sankey_patient,file="./sankey_plot_patient.pptx")
```

```{r}
# 加载必要的包
library(ggalluvial)
library(export)

# 读取数据
final_predict <- read.csv("./EQpredict_patient_level.csv")
# true_label <- read.csv("./label4patients.csv") # Uncomment if needed
sankeydf <- data.frame(y_pred = final_predict$Vote_max_slides_EQ, y_true = EQ_Clinical$SNF)
sankeydf <- sankeydf[complete.cases(sankeydf), ]
sankeydf$y_pred <- paste("im-", sankeydf$y_pred, sep = "")

# 设置颜色
colors <- c("#00468BFF", "#ED0000FF", "#42B540FF", "#0099B4FF")

# 绘制桑基图
Sankey_patient <- ggplot(sankeydf,
                         aes(y = NULL,
                             axis1 = y_pred, axis2 = y_true)) +
  geom_alluvium(aes(fill = y_pred)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), reverse = TRUE, size = 3, angle = 2, discern = TRUE) +
  scale_x_continuous(breaks = 1:2, labels = c("IM_ECMS", "ECMS")) +
  scale_fill_manual(values = colors) +
  theme(legend.position = "none") +
  ggtitle(" ")

# 显示桑基图
print(Sankey_patient)

# 生成列联表
contingency_table <- table(sankeydf$y_pred, sankeydf$y_true)

# 卡方检验
chi_test <- chisq.test(contingency_table)

# 输出结果
cat("Chi-squared test results:\n")
print(chi_test)
cat("\nP-value:", chi_test$p.value, "\n")

```

```{r}
# 加载必要的包
library(caret)
library(ggplot2)
sankeydf$y_true <- paste("im-ECMS", sankeydf$y_true, sep = "")

# 生成混淆矩阵
confusion_matrix <- confusionMatrix(as.factor(sankeydf$y_pred), as.factor(sankeydf$y_true))

# 打印混淆矩阵统计信息
print(confusion_matrix)

# 提取混淆矩阵数据
cm_table <- as.table(confusion_matrix$table)

# 转换为数据框格式用于可视化
cm_df <- as.data.frame(cm_table)
colnames(cm_df) <- c("Prediction", "Reference", "Freq")

# 绘制混淆矩阵图
confusion=ggplot(cm_df, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile(color = "white") +
  geom_text(aes(label = Freq), vjust = 1) +
  scale_fill_gradient(low = "lightblue", high = "blue") +
  theme_minimal() +
  labs(title = "Confusion Matrix", x = "True Label", y = "Predicted Label") +
  theme(plot.title = element_text(hjust = 0.5))
graph2ppt(x=confusion,file="./confusion.pptx")
```



```{r}
#EQ——sankeyplot_slide_level
library(ggalluvial)
library(export)

#ture_label=read.csv("./label4slides.csv")
sankeydf <- data.frame(y_pred = Pred_EQ, y_true = ture_label$Label4slides)

sankeydf$y_pred <- paste("im-", sankeydf$y_pred, sep = "")

colors=c("#00468BFF", "#ED0000FF", "#42B540FF", "#0099B4FF","black")
Sankey=ggplot(sankeydf,
       aes(y =NULL,
           axis1 = y_pred, axis2 = y_true))+#定义图形绘制
  geom_alluvium(aes(fill = y_pred))+#控制线条流向 
  geom_stratum() +#控制中间框的宽度 
 geom_text(stat = "stratum", aes(label = after_stat(stratum)),reverse = TRUE, size = 3,angle=2,discern = TRUE)+ #定义中间的文字
  scale_x_continuous(breaks = 1:2, labels = c("IM_ECMS", "EMCS"))+#定义X轴上图标排序
  scale_fill_manual(values = colors) +
  theme(legend.position = "none") +#定义图例有无
 ggtitle("slide_level")#定义图名
#graph2ppt(x=Sankey,file="sankey_plot.pptx")
```

```{r}
library(ggalluvial)
library(export)

#ture_label=read.csv("./label4slides.csv")
sankeydf <- data.frame(y_pred = Pred_EQ_core, y_true = temp1$Label4slides_selected)

sankeydf$y_pred <- paste("im-", sankeydf$y_pred, sep = "")

colors=c("#00468BFF", "#ED0000FF", "#42B540FF", "#0099B4FF")
Sankey=ggplot(sankeydf,
       aes(y =NULL,
           axis1 = y_pred, axis2 = y_true))+#定义图形绘制
  geom_alluvium(aes(fill = y_pred))+#控制线条流向 
  geom_stratum() +#控制中间框的宽度 
 geom_text(stat = "stratum", aes(label = after_stat(stratum)),reverse = TRUE, size = 3,angle=2,discern = TRUE)+ #定义中间的文字
  scale_x_continuous(breaks = 1:2, labels = c("IM_ECMS", "EMCS"))+#定义X轴上图标排序
  scale_fill_manual(values = colors) +
  theme(legend.position = "none") +#定义图例有无
 ggtitle("slide_level")#定义图名
#graph2ppt(x=Sankey,file="sankey_plot.pptx")
```

```{r}
# 假设您的数据框名为df，左边的列名为"Predicted"，右边的列名为"Actual"
predicted <- sankeydf$y_pred
predicted <- substr(sankeydf$y_pred, start = 8, stop = nchar(sankeydf$y_pred))
actual <- sankeydf$y_true

# 计算每个类别的敏感性、特异性和准确度
class_names <- unique(c(predicted, actual))
results <- data.frame(Class = character(), Sensitivity = numeric(), Specificity = numeric(), Accuracy = numeric(), stringsAsFactors = FALSE)

for (class_name in class_names) {
  # 计算真阳性（TP）、假阳性（FP）、真阴性（TN）、假阴性（FN）
  TP <- sum(predicted == class_name & actual == class_name)
  FP <- sum(predicted == class_name & actual != class_name)
  TN <- sum(predicted != class_name & actual != class_name)
  FN <- sum(predicted != class_name & actual == class_name)
  
  # 计算敏感性（Sensitivity）
  sensitivity <- TP / (TP + FN)
  
  # 计算特异性（Specificity）
  specificity <- TN / (TN + FP)
  
  # 计算准确度（Accuracy）
  accuracy <- (TP + TN) / (TP + FP + TN + FN)
  
  # 将结果添加到数据框中
  result <- data.frame(Class = class_name, Sensitivity = sensitivity, Specificity = specificity, Accuracy = accuracy, stringsAsFactors = FALSE)
  results <- rbind(results, result)
}

# 打印结果
print(results)
```

```{r}
#假设您的数据框名为df，左边的列名为"Predicted"，右边的列名为"Actual"
predicted <- sankeydf$y_pred
predicted <- substr(sankeydf$y_pred, start = 8, stop = nchar(sankeydf$y_pred))
actual <- sankeydf$y_true

# 计算每个类别的AUC
library(pROC)
class_names <- unique(actual)
auc_results <- data.frame(Class = character(), AUC = numeric(), stringsAsFactors = FALSE)

for (class_name in class_names) {
  class_actual <- ifelse(actual == class_name, 1, 0)
  class_predicted <- as.numeric(ifelse(predicted == class_name, 1, 0))
  roc_obj <- roc(class_actual, class_predicted)
  auc <- auc(roc_obj)
  result <- data.frame(Class = class_name, AUC = auc, stringsAsFactors = FALSE)
  auc_results <- rbind(auc_results, result)
}

# 打印结果
print(auc_results)
```
